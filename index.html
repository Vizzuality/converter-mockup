<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="https://landgriffon.com/favicon.ico">
  <title>Geo Converter</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <style>
	  /* ===== Light dashboard look (inspired by screenshot) ===== */
	  :root{
	    --bg:#f6f7fb;
	    --panel:#ffffff;
	    --text:#111827;          /* gray-900 */
	    --muted:#6b7280;         /* gray-500/600 */
	    --border:#e5e7eb;        /* gray-200 */
	    --ring:#93c5fd;          /* blue-300 */
	    --primary:#3b82f6;       /* blue-500 */
	    --primary-600:#2563eb;   /* blue-600 */
	    --amber:#f59e0b;         /* amber-500 */
	    --purple:#8b5cf6;        /* violet-500 */
	    --success:#10b981;       /* emerald-500 */
	    --danger:#ef4444;        /* red-500 */
	  }

	  html,body{height:100%}
	  body{
	    margin:0;
	    font:16px/1.5 Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Helvetica, Arial, sans-serif;
	    color:var(--text);
	    background:var(--bg);
	    -webkit-font-smoothing:antialiased;
	    -moz-osx-font-smoothing:grayscale;
	  }

	  .wrap{max-width:1200px; margin:32px auto; padding:0 20px}

	  header{
	    display:flex; gap:12px; align-items:center; margin-bottom:18px
	  }
	  header h1{
	    font-size:18px; font-weight:700; margin:0; letter-spacing:.1px; color:#0f172a
	  }
	  header .tag{
	    font-size:12px; color:#475569; background:#eef2ff; border:1px solid #e0e7ff;
	    padding:2px 8px; border-radius:999px
	  }

	  /* Layout cards */
	  .card{
	    background:var(--panel);
	    border:1px solid var(--border);
	    border-radius:16px;
	    padding:16px;
	    box-shadow:0 1px 2px rgba(16,24,40,.04);
	  }
	  .grid{display:grid; grid-template-columns:1fr; gap:16px}
	  /* @media (min-width:1024px){ .grid{grid-template-columns:1.15fr .85fr} } */

	  .muted{color:var(--muted)}

	  a{color:var(--primary); text-decoration:none}
	  a:hover{text-decoration:underline}

	  /* Dropzone */
	  .drop{
	    border:2px dashed #dbe3f2;
	    border-radius:14px;
	    padding:18px;
	    text-align:center;
	    background:#fafbff;
	    transition:.2s;
	  }
	  .drop.drag{
	    background:#eff6ff;
	    border-color:var(--primary);
	  }
	  /* ensure we only show the custom button */
	  .drop { position: relative; }

	  /* visually hide the native file input but keep it accessible */
	  .drop input[type="file"]{
	    position: absolute;
	    width: 1px; height: 1px;
	    padding: 0; margin: -1px; border: 0;
	    overflow: hidden;
	    clip: rect(0 0 0 0);
	    clip-path: inset(50%);
	    white-space: nowrap;
	  }

	  /* Inputs */
	  label{display:block; font-size:12px; color:#4b5563; margin-bottom:6px; font-weight:600}
	  input[type="text"]{
	    width:100%;
	    background:#fff;
	    border:1px solid var(--border);
	    color:var(--text);
	    padding:10px 12px;
	    border-radius:12px;
	    transition:border-color .15s, box-shadow .15s;
	  }
	  input[type="text"]:focus{
	    outline:none;
	    border-color:var(--primary);
	    box-shadow:0 0 0 3px var(--ring);
	  }
	  textarea{
	    width:90%; border:1px solid var(--border); border-radius:12px; padding:10px 12px;
	    background:#fff; color:var(--text); font:14px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
	  }
	  textarea:focus{ outline:none; border-color:var(--primary); box-shadow:0 0 0 3px var(--ring); }
	  .checkbox-line{
	    display:flex; align-items:center; gap:10px;
	    background:#fff; border:1px solid var(--border); padding:10px 12px; border-radius:12px
	  }
	  
	  

	  /* Buttons */
	  .btn{
	    appearance:none; cursor:pointer; user-select:none;
	    border:1px solid var(--border);
	    background:#fff; color:#111827;
	    padding:10px 14px; border-radius:10px; font-weight:600;
	    transition:transform .02s ease, box-shadow .15s, border-color .15s, background .15s;
	    box-shadow:0 1px 1px rgba(16,24,40,.05);
	  }
	  .btn:hover{border-color:#cdd5e1; background:#f8fafc}
	  .btn:active{transform:translateY(1px)}
	  .btn:disabled{opacity:.6; cursor:not-allowed}

	  .btn.primary{
	    background:var(--primary); color:#fff; border-color:var(--primary);
	    box-shadow:0 1px 1px rgba(59,130,246,.25);
	  }
	  .btn.primary:hover{background:var(--primary-600); border-color:var(--primary-600)}
	  .btn.ghost{background:transparent}

	  /* Output panel */
	  .out{
	    background:#fff;
	    border:1px solid var(--border);
	    border-radius:12px;
	    padding:12px;
	  }

	  /* Progress */
	  .progress{height:8px; background:#eef2f7; border:1px solid var(--border); border-radius:999px; overflow:hidden}
	  .bar{height:100%; width:0%; background:var(--primary); transition:width .2s}

	  /* Tabs (buttons already .btn.ghost) */
	  .tabs{display:flex; gap:8px; align-items:center; margin-top:10px}
	  .tabs .btn.ghost{
	    border-color:transparent; background:transparent; color:#334155; padding:8px 10px;
	  }
	  .tabs .btn.ghost:hover{background:#f1f5f9}
	  .panel{display:none; margin-top:12px}
	  .panel.active{display:block}

	  /* Map & JSON preview */
	  #map{
	    height:460px;
	    border-radius:16px;
	    overflow:hidden;
	    border:1px solid var(--border);
	    box-shadow:inset 0 0 0 1px rgba(15,23,42,.02);
	  }
	  pre{
	    background:#f9fafb; color:#0f172a;
	    border:1px solid var(--border); border-radius:12px;
	    padding:12px; max-height:460px; overflow:auto;
	    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:13px;
	  }

	  /* Small helpers */
	  .kbd{
	    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
	    background:#f1f5f9; border:1px solid var(--border);
	    padding:2px 6px; border-radius:6px; color:#334155
	  }
	  .error{color:var(--danger)}

	  /* Lists in aside */
	  aside.card h3{font-size:14px; margin:0 0 8px; color:#0f172a}
	  aside.card ol{margin:0; padding-left:18px}
	  aside.card li{margin:8px 0}

	  /* Summary chips (right side of tabs) */
	  #summary{
	    margin-left:auto; font-size:12px; color:#475569; padding:4px 8px;
	    background:#f1f5f9; border:1px solid var(--border); border-radius:999px
	  }
	  
	  /* China controls grouped */
	  .china-group{
	    display:flex; align-items:center; gap:12px;
	    background:#fff; border:1px solid var(--border); border-radius:12px;
	    padding:8px 12px; margin-top:8px;
	  }
	  .china-group .checkbox-line{
	    margin:0; padding:8px 10px; border:0; background:transparent;
	  }
	  .china-group select{
	    appearance:none;
	    background:#fff; border:1px solid var(--border); border-radius:12px;
	    padding:9px 12px;
	  }
	  /* Stack on small screens */
	  @media (max-width:640px){
	    .china-group{ flex-direction:column; align-items:stretch }
	    .china-group select{ width:100% }
	  }

	  /* Filename + validation text */
	  #fname{color:#334155}
	  #validation{color:#a16207}          /* amber-ish feedback */

	  /* Subtle accent badges you might print in text */
	  .badge-blue{color:#1d4ed8; background:#e0e7ff; border:1px solid #c7d2fe; padding:2px 8px; border-radius:999px}
	  .badge-amber{color:#92400e; background:#fef3c7; border:1px solid #fde68a; padding:2px 8px; border-radius:999px}
	  .badge-purple{color:#6d28d9; background:#ede9fe; border:1px solid #ddd6fe; padding:2px 8px; border-radius:999px}
	  
	  
	  .hidden{ display:none !important }
	  .tabs.small .btn.ghost.active{ background:#eaf2ff; border-color:#cfe0ff }

	  /* Make buttons/inputs look good on mobile */
	  @media (max-width:480px){
	    .btn{width:100%}
	    .row{flex-direction:column}
	  }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="https://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 3l8 4.5v9L12 21l-8-4.5v-9L12 3z" stroke="#8ad2ff" stroke-width="1.5"/><path d="M12 7l4 2.25v4.5L12 16l-4-2.25v-4.5L12 7z" stroke="#9fffad"/></svg>
	
    <h1>Geo Converter</h1>
    <span class="tag">demo / mockup</span>
  </header>

  <div class="grid">
    <section class="card">
		<div class="tabs small" id="inputTabs" style="margin-bottom:8px">
		  <button data-inputtab="paste" class="btn ghost active">Paste</button>
		  <button data-inputtab="upload" class="btn ghost">Upload</button>
		</div>
      <div id="drop" class="drop hidden" role="region" aria-label="File drop area" tabindex="0">
        <input id="file" type="file" aria-label="Choose a geospatial file" />
        <p><strong>Select or drop a geospatial file</strong></p>
        <p class="muted">Supports many formats (e.g., zipped Shapefile, KML, GML, MapInfo, DXF, etc.). For Shapefile, <em>zip</em> the .shp/.shx/.dbf (+ optional .prj) together.</p>
        <div style="margin-top:10px"><button id="choose" class="btn">Choose file…</button></div>
        <p id="fname" class="muted" style="margin-top:8px"></p>
        <p id="validation" class="muted" style="margin-top:6px"></p>
        <div style="display:flex; gap:10px; align-items:center; margin-top:14px">
          <button id="convert" class="btn primary">Convert to GeoJSON</button>
          <div class="progress" style="flex:1"><div id="bar" class="bar"></div></div>
          <span id="status" class="muted" aria-live="polite"></span>
        </div>
      </div>
      
		  
	<!-- === Paste coordinates (auto-detect) === -->
	<div id="paste" class="drop" style="margin-top:12px">
	  <p><strong>Paste coordinates</strong></p>
	  <p class="muted" style="margin-top:0">
	    Paste coords from Google Maps, Baidu, GPS, etc. The app will guess the format (lat,lon · [lat,lon] · lists · DMS · UTM · WKT · GeoJSON · ECEF · simple MGRS).
	  </p>
	  <textarea id="coordsInput" rows="4" placeholder="Examples:
	  40.4168,-3.7038
	  [40.4168, -3.7038]
	  40°25'0&quot;N 3°42'0&quot;W
	  30T 440000 4470000
	  POINT(-3.7038 40.4168)
	  { &quot;type&quot;: &quot;Point&quot;, &quot;coordinates&quot;: [-3.7038, 40.4168] }
	  ECEF(4843520, -360093, 4115200)
	  4QFJ 12345 67890"></textarea>
	<!-- chinaCoords/chinaType -->
	<div class="china-group">
	  <label class="checkbox-line">
	    <input id="chinaCoords" type="checkbox" />
	    <span>Coordinates from China map</span>
	  </label>
	  <select id="chinaType">
	    <option value="gcj02">GCJ-02 (Gaode/Amap, Tencent/QQ, Apple in CN)</option>
	    <option value="bd09">BD-09 (Baidu)</option>
	  </select>
	</div>
	  <div class="row" style="margin-top:8px">
	    <button id="coordsPreview" class="btn primary">Parse & Preview</button>
	    <button id="coordsUse" class="btn">Replace current GeoJSON</button>
	  </div>
	  <p id="coordsMsg" class="muted" style="margin-top:8px"></p>
	</div>
      

      <div id="result" style="margin-top:14px; display:none">
        <div class="out">
	      <div style="display:flex; align-items:center; gap:10px; justify-content:space-between; flex-wrap:wrap">
	        <div>
	          <div><strong>Location:</strong> </div>
	          <div class="muted" id="hint"></div>
	        </div>
	        
	      </div>
		  
		  

          <div class="tabs">
            <button data-tab="map" class="btn ghost" aria-controls="panel-map">Preview map</button>
            <button data-tab="json" class="btn ghost" aria-controls="panel-json">Raw JSON</button>
            <span id="summary" class="muted" style="margin-left:auto"></span>
          </div>
          <div id="panel-map" class="panel">
            <div id="map"></div>
          </div>
          <div id="panel-json" class="panel">
            <pre id="json"></pre>
          </div>
        </div>
		
	  <div id="gfwPanel" class="card" style="margin-top:12px; display:none">
	    <h4 style="margin-top:0">Validation</h4>		
	    <p id="gfwMsg" class="muted" style="margin-top:8px"></p>
		
        <div style="display:flex; gap:8px">
          <button id="copy" class="btn">Copy JSON</button>
          <a id="download" class="btn" download>Download GeoJSON</a>
        </div>
	  </div>
	  

	  
	  
      </div>

      <p id="err" class="error" role="alert" style="display:none; margin-top:12px"></p>
    </section>


  </div>
</div>

<script>
(function(){
  const el = (id) => document.getElementById(id);
  const qs = (sel, root=document) => root.querySelector(sel);
  const fileInput = el('file');
  const drop = el('drop');
  const choose = el('choose');
  const convertBtn = el('convert');
  const bar = el('bar');
  const status = el('status');
  const err = el('err');
  const result = el('result');
  const meta = el('meta');
  const hint = el('hint');
  const download = el('download');
  const copyBtn = el('copy');
  const validation = el('validation');
  const panelMap = el('panel-map');
  const panelJSON = el('panel-json');
  const summary = el('summary');

  const endpoint = 'https://ogre.adc4gis.com/convert';

  let selectedFile = null;
  let lastGeoJSON = null;
  let map = null;
  let layer = null;
  let lastInputSource = null;   // 'pasted' | 'uploaded'
  let lastParseMeta   = null;   // detalles de interpretación del pegado
  let lastDetectedLocation = null;

  function resetUI(){
    err.style.display = 'none';
    result.style.display = 'none';
    bar.style.width = '0%';
    status.textContent = '';
    summary.textContent = '';
    lastGeoJSON = null;
  }

  function setError(msg){
    err.textContent = msg;
    err.style.display = 'block';
  }

  function setProgress(p,label){
    bar.style.width = Math.max(0, Math.min(100, p)) + '%';
    if(label) status.textContent = label;
  }
  function showGfwPanel(){ const p = document.getElementById('gfwPanel'); if(p) p.style.display = 'block'; }
  function scrollToResult(){
    const box = document.getElementById('result');
    if (!box) return;
    box.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }

  const allowedExt = ['.zip','.kml','.kmz','.gml','.tab','.mif','.dxf','.gpx','.csv','.json','.geojson'];
  function validateSelected(file){
    if(!file){ validation.textContent = ''; return true; }
    const name = file.name.toLowerCase();
    const ext = name.slice(name.lastIndexOf('.'));
    let messages = [];

    if(!allowedExt.includes(ext)){
      messages.push(`Unknown extension “${ext}”. It may still work if GDAL supports it, but common ones are ${allowedExt.join(', ')}.`);
    }

    if(ext === '.shp'){
      messages.push('Shapefile must be uploaded as a ZIP containing .shp/.shx/.dbf (and ideally .prj).');
    }

    if(file.size > 18 * 1024 * 1024){
      messages.push('Large file (>18 MB). Public Ogre may reject it.');
    }

    validation.textContent = messages.join(' ');
    return true; // Non-blocking validation
  }

  function switchTab(which){
    const showMap = which === 'map';
    panelMap.classList.toggle('active', showMap);
    panelJSON.classList.toggle('active', !showMap);
    if(showMap && lastGeoJSON){ ensureMap(); drawGeoJSON(lastGeoJSON); }
  }
  
  // --- Basemaps (no API keys) ---
  const BASE_OSM = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  });

  // Esri World Imagery + reference overlays (labels/roads). Publicly accessible tiles; keep attribution.
  const ESRI_IMAGERY = L.tileLayer(
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    { attribution: 'Tiles &copy; Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community' }
  );

  const ESRI_LABELS = L.tileLayer(
    'https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
    { attribution: 'Labels &copy; Esri', pane: 'overlayPane' }
  );

  const ESRI_ROADS = L.tileLayer(
    'https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}',
    { attribution: 'Roads &copy; Esri', pane: 'overlayPane' }
  );

  function ensureMap(){
    if (map) { setTimeout(()=> map.invalidateSize(), 50); return; }
    map = L.map('map');

    // Default: Satellite + Labels (and Roads)
    ESRI_IMAGERY.addTo(map);
    ESRI_LABELS.addTo(map);
    ESRI_ROADS.addTo(map);

    // Layer control: basemaps + overlays
    const baseLayers = {
      'Satellite (Esri)': ESRI_IMAGERY,
      'OpenStreetMap': BASE_OSM
    };
	// GFW overlays (use same dataset versions as queries)
	const lossTiles = L.tileLayer(TILE_LOSS, {
	  opacity: 0.6,
	  attribution: '&copy; GFW / UMD Hansen'
	});
	const plantationsTiles = L.tileLayer(TILE_PLANT, {
	  opacity: 0.7,
	  attribution: '&copy; GFW / SDPT'
	});
	const woodFiberTiles = L.tileLayer(TILE_WOOD, {
	  opacity: 0.7,
	  attribution: '&copy; GFW / Wood fiber'
	});
	const managedTiles = L.tileLayer(TILE_MANAGED, {
	  opacity: 0.7,
	  attribution: '&copy; GFW / Managed forests'
	});

	const overlays = {
	  'Place names': ESRI_LABELS,
	  'Roads': ESRI_ROADS,
	  'Tree cover loss (v1.12)': lossTiles,
	  'Planted forests (v20231128)': plantationsTiles,
		/*
	  'Wood fiber (v202106)': woodFiberTiles,
	  'Managed forests (v202106)': managedTiles
		*/
	};

	// Añadir mapa + control
	L.control.layers(baseLayers, overlays, { collapsed: true }).addTo(map);


    map.setView([0,0], 2);
  }

  function drawGeoJSON(geo){
    if(layer){ layer.remove(); layer = null; }
    layer = L.geoJSON(geo, {
      onEachFeature: function (feature, lyr) {
        const props = feature && feature.properties ? feature.properties : {};
        const html = '<pre style="margin:0;white-space:pre-wrap">' + escapeHtml(JSON.stringify(props, null, 2)) + '</pre>';
        lyr.bindPopup(html);
      }
    }).addTo(map);

    try{
      map.fitBounds(layer.getBounds(), { padding:[20,20] });
    }catch(e){ map.setView([0,0], 2); }
  }

  function summarizeGeoJSON(geo){
    let features = 0;
    let types = new Set();
    let bbox = null;
    if(geo.type === 'FeatureCollection'){
      features = (geo.features || []).length;
      (geo.features||[]).forEach(f=>{ if(f && f.geometry && f.geometry.type) types.add(f.geometry.type); });
    } else if(geo.type === 'Feature' && geo.geometry){
      features = 1; types.add(geo.geometry.type);
    } else if(geo.type){
      features = 1; types.add(geo.type);
    }
    if(geo.bbox && Array.isArray(geo.bbox) && geo.bbox.length===4){
      bbox = geo.bbox.map(n=> Number(n).toFixed(4)).join(', ');
    }
    const typeStr = Array.from(types).join(' · ');
    summary.textContent = `${features} feature(s) • ${typeStr}${bbox?` • bbox: ${bbox}`:''}`;
  }

  function escapeHtml(s){ return s.replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }

  // File picking
  choose.addEventListener('click', ()=> fileInput.click());
  fileInput.addEventListener('change', ()=>{
    resetUI();
    selectedFile = fileInput.files[0] || null;
    el('fname').textContent = selectedFile ? `Selected: ${selectedFile.name} (${(selectedFile.size/1024/1024).toFixed(2)} MB)` : '';
    validateSelected(selectedFile);
  });

  // Drag and drop
  const prevent = (e)=>{e.preventDefault(); e.stopPropagation();};
  ['dragenter','dragover','dragleave','drop'].forEach(evt=> drop.addEventListener(evt, prevent));
  ['dragenter','dragover'].forEach(evt=> drop.addEventListener(evt, ()=> drop.classList.add('drag')));
  ;['dragleave','drop'].forEach(evt=> drop.addEventListener(evt, ()=> drop.classList.remove('drag')));
  drop.addEventListener('drop', (e)=>{
    resetUI();
    const dt = e.dataTransfer;
    if(dt && dt.files && dt.files.length){
      selectedFile = dt.files[0];
      el('fname').textContent = `Selected: ${selectedFile.name} (${(selectedFile.size/1024/1024).toFixed(2)} MB)`;
      validateSelected(selectedFile);
    }
  });

  // Tabs
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest('button[data-tab]');
    if(!btn) return;
    switchTab(btn.getAttribute('data-tab'));
  });
  
  // input tabs: paste/upload
  const inputTabs = document.getElementById('inputTabs');
  const dropBox   = document.getElementById('drop');
  const pasteBox  = document.getElementById('paste');
  inputTabs?.addEventListener('click', (e)=>{
    const btn = e.target.closest('button[data-inputtab]');
    if(!btn) return;
    inputTabs.querySelectorAll('button').forEach(b=> b.classList.toggle('active', b===btn));
    const tab = btn.getAttribute('data-inputtab');
    if(tab==='paste'){
      pasteBox?.classList.remove('hidden');
      dropBox?.classList.add('hidden');
      document.getElementById('coordsInput')?.focus();
    }else{
      dropBox?.classList.remove('hidden');
      pasteBox?.classList.add('hidden');
      document.getElementById('choose')?.focus();
    }
  });
  function fcFirstTwoCoords(fc){
    // encuentra hasta dos pares [lon,lat] en el primer feature/geom
    const out = [];
    function pushPair(xy){ if (Array.isArray(xy) && xy.length>=2 && out.length<2) out.push([+xy[0], +xy[1]]); }
    function walkGeom(g){
      if(!g) return;
      const t = g.type;
      if(t==='Point'){ pushPair(g.coordinates); }
      else if(t==='MultiPoint' || t==='LineString'){ (g.coordinates||[]).forEach(pushPair); }
      else if(t==='Polygon' || t==='MultiLineString'){ (g.coordinates?.[0]||[]).forEach(pushPair); }
      else if(t==='MultiPolygon'){ (g.coordinates?.[0]?.[0]||[]).forEach(pushPair); }
      else if(t==='GeometryCollection'){ (g.geometries||[]).forEach(walkGeom); }
    }
    if(fc.type==='FeatureCollection'){ const f=fc.features?.[0]; walkGeom(f?.geometry); }
    else if(fc.type==='Feature'){ walkGeom(fc.geometry); }
    else { walkGeom(fc); }
    return out;
  }

  function buildHintFromMeta(source, meta, fc){
    if(source === 'uploaded'){
      // muestra formato original → GeoJSON
      const name = (selectedFile?.name || '').toLowerCase();
      const ext = name.includes('.') ? name.slice(name.lastIndexOf('.')) : '';
      return `Uploaded file converted${ext?` from ${ext}`:''} to GeoJSON.`;
    }

    // pasted
    if(!meta) return 'Generated from pasted text.';
    const coords = fcFirstTwoCoords(fc);
    const two = coords.slice(0,2).map(c => `[${c[0].toFixed(6)}, ${c[1].toFixed(6)}]`).join(' , ');
    const type = (()=>{
      if(fc.type==='FeatureCollection'){
        const f=fc.features?.[0]; return f?.geometry?.type || 'Unknown';
      }
      if(fc.type==='Feature') return fc.geometry?.type || 'Unknown';
      return fc.type || 'Unknown';
    })();

    // base line
    let msg = '';
    if(meta.kind === 'geojson') msg = 'Pasted GeoJSON detected.';
    else if(meta.kind === 'wkt') msg = `Pasted WKT (${meta.wktType}).`;
    else if(meta.kind === 'dms') msg = 'Pasted DMS converted to decimal.';
    else if(meta.kind === 'utm') msg = 'Pasted UTM converted to WGS84.';
    else if(meta.kind === 'ecef') msg = 'Pasted ECEF converted to WGS84.';
    else if(meta.kind === 'decimal') msg = 'Pasted decimal coordinates.';

    // details per geometry
    if(type === 'Point'){
      const c = coords[0];
      if (c) msg += ` Interpreted as point: lat ${c[1].toFixed(6)}, lon ${c[0].toFixed(6)}.`;
    } else {
      msg += ` Interpreted as ${type}. First coords: ${two || 'n/a'}.`;
    }

    // axis decision explanation (only for decimal-list path) -- leave it out for now, as it gets confusing
    if(meta.kind === 'decimal'){
      if(meta.axisSwitched){
        //msg += ` Axis switched (${meta.axisDecision}) because ${meta.axisReason}.`;
      }else if(meta.axisDecision){
        //msg += ` Axis kept (${meta.axisDecision}) because ${meta.axisReason}.`;
      }
    }

    return msg;
  }
  // === Reverse geocoding (no key) ===
  // Centro de un GeoJSON (bbox centroid)
  function getGeoJSONCenter(geo){
    // Flatten coords and compute bbox
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    const push = (xy)=>{ if(!xy||xy.length<2) return; const x=+xy[0], y=+xy[1];
      if (isFinite(x) && isFinite(y)) { if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; } };
    (function walk(g){
      if(!g) return;
      const t=g.type;
      if(t==='FeatureCollection'){ (g.features||[]).forEach(f=>walk(f)); }
      else if(t==='Feature'){ walk(g.geometry); }
      else if(t==='Point'){ push(g.coordinates); }
      else if(t==='MultiPoint'||t==='LineString'){ (g.coordinates||[]).forEach(push); }
      else if(t==='Polygon'||t==='MultiLineString'){
        (g.coordinates||[]).forEach(r=> (r||[]).forEach(push));
      }else if(t==='MultiPolygon'){
        (g.coordinates||[]).forEach(p=> (p||[]).forEach(r=> (r||[]).forEach(push)));
      }else if(t==='GeometryCollection'){ (g.geometries||[]).forEach(walk); }
    })(geo);
    if(!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)){
      return null;
    }
    return [(minX+maxX)/2, (minY+maxY)/2]; // [lon, lat]
  }

  // Llama a Nominatim y devuelve {region, country} o null
  async function reverseGeocodeOSM(lon, lat){
    // idioma en inglés para homogeneidad (ajústalo si quieres 'es')
    const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&accept-language=en&zoom=5&addressdetails=1`;
    const res = await fetch(url, { method:'GET', headers:{ 'Accept':'application/json' } });
    if(!res.ok) return null;
    const j = await res.json();
    const a = j && j.address || {};
    // Algunas regiones vienen como state / region / province / county
    const region = a.state || a.region || a.province || a.county || null;
    const country = a.country || null;
    if(!region && !country) return null;
    return { region, country };
  }

  // Inserta "Region, Country — " al principio del hint (si tenemos centro)
  async function updateHintWithLocation(fc){
    const center = getGeoJSONCenter(fc);
    if(!center) return;
    const [lon, lat] = center;
    try{
      // Respetar ~1 req/s si fueras a hacer muchas (aquí es esporádico)
      const place = await reverseGeocodeOSM(lon, lat);
      if(!place) return;
	  // Guarda para uso futuro 
	  lastDetectedLocation = place;
	  console.log('Detected location:', lastDetectedLocation);
      const prefix = `${place.region ? (place.region + ', ') : ''}${place.country || ''}`.trim().replace(/^[, ]+|[, ]+$/g,'');
      if(!prefix) return;
      const hintEl = document.getElementById('hint');
      if(!hintEl) return;
      // Prepend ubicación
      //hintEl.textContent = `${prefix} — ${hintEl.textContent}`;
	  hintEl.innerHTML = `<strong>${prefix}</strong> — ${hintEl.textContent}`;
    }catch(_){ /* silencioso si falla */ }
  }

  async function convert(){
    resetUI();
	lastInputSource = 'uploaded';
	lastParseMeta   = null;
    if(!selectedFile){ setError('Please select a file first.'); return; }

    validateSelected(selectedFile);

    convertBtn.disabled = true;
    setProgress(8,'Uploading…');

    try{
      const form = new FormData();
      form.append('upload', selectedFile, selectedFile.name);
      const src = null;
      const dst = null;
      const rfc = false;
      if(src) form.append('sourceSrs', src);
      if(dst) form.append('targetSrs', dst);
      if(rfc) form.append('rfc7946', 'true');

      const res = await fetch(endpoint, { method:'POST', body: form });

      setProgress(50,'Converting on server…');

      let text = await res.text();
      if(!res.ok){
        let msg = text || `HTTP ${res.status}`;
        try{ const j = JSON.parse(text); if(j && j.errors) msg = j.errors.join('; ');}catch(_){ }
        throw new Error(msg);
      }

      // Parse and validate GeoJSON
      let geo = null; let parsed = null;
      try { parsed = JSON.parse(text); } catch(_){ }
      if(parsed && (parsed.type === 'FeatureCollection' || parsed.type === 'Feature' || parsed.geometry)){
        geo = parsed;
      }

      const blob = new Blob([text], { type: 'application/geo+json' });
      const url = URL.createObjectURL(blob);
      download.href = url;
      const safeName = (selectedFile.name.replace(/\.[^.]+$/,'') || 'data') + '.geojson';
      download.setAttribute('download', safeName);
      el('json').textContent = text;
	  hint.textContent = buildHintFromMeta('uploaded', null, geo);
	  updateHintWithLocation(geo); // ← añade país/región
      result.style.display = 'block';
      setProgress(100,'Done');

      if(geo){
        lastGeoJSON = geo;
        summarizeGeoJSON(geo);
		switchTab('map');
		showGfwPanel();
		//toggleLossTiles();
		//togglePlantationsTiles();
		scrollToResult();
		runGfwValidation();
      } else {
        switchTab('json');
      }
    } catch(e){
      console.error(e);
      setError('Conversion failed: ' + (e && e.message ? e.message : e));
    } finally {
      convertBtn.disabled = false;
    }
  }

  copyBtn.addEventListener('click', async ()=>{
    try{
      const txt = el('json').textContent || '';
      await navigator.clipboard.writeText(txt);
      copyBtn.textContent = 'Copied';
      setTimeout(()=> copyBtn.textContent = 'Copy JSON', 1000);
    }catch(_){ /* ignore */ }
  });

  convertBtn.addEventListener('click', convert);
  drop.addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ fileInput.click(); } });
  
  // ====== Coordinate parsing & guessing ======
  (function(){
	  lastParseMeta = null;
    const tArea = document.getElementById('coordsInput');
    const btnPrev = document.getElementById('coordsPreview');
    const btnUse  = document.getElementById('coordsUse');
    const msg     = document.getElementById('coordsMsg');

    if(!tArea) return; // panel no presente

    // Helpers
    const deg2rad = d => d*Math.PI/180;
    const rad2deg = r => r*180/Math.PI;

    // --- DMS parser (e.g., 40°25'0"N 3°42'0"W or 40 25 0 N, 3 42 0 W) ---
    function dmsToDec(deg, min=0, sec=0, hem=null){
      let sign = 1;
      if(hem){ if(/[SW]/i.test(hem)) sign = -1; }
      const val = Math.abs(deg) + (Math.abs(min)/60) + (Math.abs(sec)/3600);
      return sign * (deg<0 ? -val : val);
    }
    function parseDMS(str){
      // returns {lat, lon} if single pair
      const s = str.replace(/,/g,' ').replace(/\s+/g,' ').trim();
      // patterns like: 40° 25' 0" N 3° 42' 0" W
      const rx = /(\d+(?:\.\d+)?)\D+(\d+(?:\.\d+)?)?\D*(\d+(?:\.\d+)?)?\s*([NnSs])\s+(\d+(?:\.\d+)?)\D+(\d+(?:\.\d+)?)?\D*(\d+(?:\.\d+)?)?\s*([EeWw])/;
      const m = s.match(rx);
      if(!m) return null;
      const lat = dmsToDec(+m[1], +(m[2]||0), +(m[3]||0), m[4]);
      const lon = dmsToDec(+m[5], +(m[6]||0), +(m[7]||0), m[8]);
	  lastParseMeta = { kind:'dms' };
      return {lat, lon};
    }

    // --- Decimal lat,lon / lon,lat lists ---
	function parseLatLonList(text){
	  const lines = text.trim()
	    .replace(/[\[\]]/g,' ')
	    .replace(/;/g,'\n')
	    .split(/\n+/)
	    .map(s => s.trim())
	    .filter(Boolean);

	  const pts = [];
	  for(const ln of lines){
	    const m = ln.replace(/,/g,' ').trim().match(/(-?\d+(?:\.\d+)?)[\s,]+(-?\d+(?:\.\d+)?)/);
	    if(!m) continue;
	    pts.push([parseFloat(m[1]), parseFloat(m[2])]);
	  }
	  if(!pts.length) return null;

  // --- Decide axis order heuristically ---
  const xs = pts.map(p=>p[0]), ys = pts.map(p=>p[1]);
  const single = pts.length === 1;
  let assumeLatLon = false;
  if (single) {
    // Prefer the common pattern: lat, lon
    const [a,b] = pts[0];
    assumeLatLon = (Math.abs(a) <= 90 && Math.abs(b) <= 180);
  } else {
    const rangeX = Math.max(...xs)-Math.min(...xs);
    const rangeY = Math.max(...ys)-Math.min(...ys);
    const allAbsX = xs.every(v=>Math.abs(v)<=180);
    const allAbsY = ys.every(v=>Math.abs(v)<=180);
    if (allAbsX && allAbsY){
      // both within ±180: decide by spread (lat usually has smaller spread)
      assumeLatLon = rangeX < rangeY;
    } else if (xs.every(v=>Math.abs(v)<=90) && ys.every(v=>Math.abs(v)<=180)){
      assumeLatLon = true; // likely lat,lon
    } else {
      assumeLatLon = false; // likely lon,lat or projected
    }
  }
	const coords = assumeLatLon
    ? pts.map(p => [p[1], p[0]]) // lat,lon → lon,lat
    : pts.map(p => [p[0], p[1]]);
	// --- Fallback si hay UN solo punto: probar ambas interpretaciones y escoger la más plausible ---
	if (coords.length === 1) {
	const [a, b] = pts[0];              // a,b vienen del texto
	const cand1 = [b, a];               // asumiendo lat,lon → lon,lat
	const cand2 = [a, b];               // asumiendo lon,lat → lon,lat (ya lo es)
	const ok = ([lon, lat]) => Math.abs(lat) <= 90 && Math.abs(lon) <= 180;
	const score = ([lon, lat]) => (ok([lon,lat]) ? Math.abs(lat) : 1e9); // preferir |lat| más razonable
	// elige la candidata válida con |lat| más baja (≤ 75° preferible)
	let best = ok(cand1) && ok(cand2)
	  ? (Math.abs(cand1[1]) <= 75 && Math.abs(cand2[1]) <= 75
	      ? (Math.abs(cand1[1]) <= Math.abs(cand2[1]) ? cand1 : cand2)
	      : (Math.abs(cand1[1]) <= 75 ? cand1 : (Math.abs(cand2[1]) <= 75 ? cand2 : (score(cand1) <= score(cand2) ? cand1 : cand2))))
	  : (ok(cand1) ? cand1 : (ok(cand2) ? cand2 : coords[0]));
	coords[0] = best;
	}
const geomType =
  (coords.length===1) ? 'Point' :
  (coords.length>=4 && Math.hypot(coords[0][0]-coords[coords.length-1][0], coords[0][1]-coords[coords.length-1][1])<1e-4)
    ? 'Polygon' :
    (coords.length===2) ? 'Polygon' : 'LineString';

let axisDecision = assumeLatLon ? 'lat,lon → lon,lat' : 'lon,lat as-is';
let axisReason = '';
if (pts.length === 1) {
  axisReason = 'single pair: valid ranges favored (|lat|≤90, |lon|≤180) and plausibility';
} else {
  axisReason = 'spread heuristic (lat spread < lon spread) or range constraints';
}

lastParseMeta = {
  kind: 'decimal',
  axisSwitched: assumeLatLon || false,
  axisDecision,
  axisReason,
  geomType
};

	  // --- Determine geometry type ---
	  const eq = (p,q)=> Math.hypot(p[0]-q[0], p[1]-q[1]) < 1e-4;
	  if(coords.length===1) return { type:'Point', coordinates: coords[0] };
	  if(coords.length>=4 && eq(coords[0], coords[coords.length-1]))
	    return { type:'Polygon', coordinates:[coords] };
	  if(coords.length===2){
	    const [a,b]=coords;
	    const ring=[[a[0],a[1]],[b[0],a[1]],[b[0],b[1]],[a[0],b[1]],[a[0],a[1]]];
	    return { type:'Polygon', coordinates:[ring] };
	  }
	  return { type:'LineString', coordinates: coords };
	}

    // --- WKT (POINT/LINESTRING/POLYGON) ---
    function parseWKT(text){
      const s = text.trim();
      const m = s.match(/^\s*(POINT|LINESTRING|POLYGON)\s*\(([\s\S]+)\)\s*$/i);
      if(!m) return null;
      const kind = m[1].toUpperCase();
      const body = m[2].trim();

      const parseCoord = (tok)=> tok.trim().split(/\s+/).map(Number).slice(0,2); // x y
      if(kind==='POINT'){
        const c = parseCoord(body);
		lastParseMeta = { kind:'wkt', wktType: kind };
        return { type:'Point', coordinates: c };
      }
      if(kind==='LINESTRING'){
        const coords = body.split(',').map(parseCoord);
		lastParseMeta = { kind:'wkt', wktType: kind };
        return { type:'LineString', coordinates: coords };
      }
      if(kind==='POLYGON'){
        // One outer ring (simple cases)
        const inner = body.replace(/^\(/,'').replace(/\)$/,'');
        const ring = inner.split(',').map(parseCoord);
		lastParseMeta = { kind:'wkt', wktType: kind };
        return { type:'Polygon', coordinates:[ring] };
      }
      return null;
    }

    // --- GeoJSON pasted tal cual ---
    function parseGeoJSON(text){
      try{
        const j = JSON.parse(text);
		lastParseMeta = { kind:'geojson' };
        if(j.type==='FeatureCollection' || j.type==='Feature' || (j.type && j.coordinates)) return j;
        return null;
      }catch(_){ return null; }
    }

    // --- UTM to WGS84 (zone, easting, northing, hemisphere) ---
    function parseUTM(text){
      // Accepts: "30T 440000 4470000" or "30 N 440000 4470000"
      const s = text.toUpperCase().replace(/[,;]/g,' ').replace(/\s+/g,' ').trim();
      const rx = /^(\d{1,2})\s*([CDEFGHJKLMNPQRSTUVWXN|S|N|T|U|V|W|X])?\s+(\d+(?:\.\d+)?)\s+(\d+(?:\.\d+)?)/;
      const m = s.match(rx);
      if(!m) return null;
      const zone = parseInt(m[1],10);
      const token = m[2] || 'N';
      const easting = parseFloat(m[3]);
      const northing = parseFloat(m[4]);
      const northHem = /[NPQRSTUVWXN]/.test(token); // band letters N..X or 'N' means northern
      const {lat, lon} = utmToLatLon(zone, easting, northing, northHem);
	  lastParseMeta = { kind:'utm' };
      return { type:'Point', coordinates:[lon,lat] };
    }
    function utmToLatLon(zone, E, N, northern){
      // WGS84 constants
      const a=6378137, f=1/298.257223563, k0=0.9996;
      const e = Math.sqrt(2*f - f*f);
      const e1sq = e*e/(1-e*e);
      const x = E - 500000;
      const y = northern ? N : N - 10000000;
      const m = y / k0;
      const mu = m / (a*(1 - e*e/4 - 3*e**4/64 - 5*e**6/256));
      const e1 = (1 - Math.sqrt(1 - e*e)) / (1 + Math.sqrt(1 - e*e));
      const J1 = (3*e1/2 - 27*e1**3/32);
      const J2 = (21*e1**2/16 - 55*e1**4/32);
      const J3 = (151*e1**3/96);
      const J4 = (1097*e1**4/512);
      const fp = mu + J1*Math.sin(2*mu) + J2*Math.sin(4*mu) + J3*Math.sin(6*mu) + J4*Math.sin(8*mu);
      const C1 = e1sq*Math.cos(fp)**2;
      const T1 = Math.tan(fp)**2;
      const R1 = a*(1-e*e)/Math.pow(1 - (e*Math.sin(fp))**2, 1.5);
      const N1 = a/Math.sqrt(1 - (e*Math.sin(fp))**2);
      const D = x/(N1*k0);
      const Q1 = N1*Math.tan(fp)/R1;
      const Q2 = (D*D/2);
      const Q3 = (5 + 3*T1 + 10*C1 - 4*C1*C1 - 9*e1sq)*Math.pow(D,4)/24;
      const Q4 = (61 + 90*T1 + 298*C1 + 45*T1*T1 - 252*e1sq - 3*C1*C1)*Math.pow(D,6)/720;
      const lat = fp - Q1*(Q2 - Q3 + Q4);
      const Q5 = D;
      const Q6 = (1 + 2*T1 + C1)*Math.pow(D,3)/6;
      const Q7 = (5 - 2*C1 + 28*T1 - 3*C1*C1 + 8*e1sq + 24*T1*T1)*Math.pow(D,5)/120;
      let lon = deg2rad((zone-1)*6 - 180 + 3) + (Q5 - Q6 + Q7)/Math.cos(fp);
      return { lat: rad2deg(lat), lon: rad2deg(lon) };
    }

    // --- ECEF(X,Y,Z) to WGS84 ---
    function parseECEF(text){
      const m = text.replace(/[(),]/g,' ').match(/ECEF\s*([-+]?\d+(?:\.\d+)?)\s+([-+]?\d+(?:\.\d+)?)\s+([-+]?\d+(?:\.\d+)?)/i);
      if(!m) return null;
      const X=+m[1], Y=+m[2], Z=+m[3];
      const {lat, lon} = ecefToLLA(X,Y,Z);
	  lastParseMeta = { kind:'ecef' };
      return { type:'Point', coordinates:[lon,lat] };
    }
    function ecefToLLA(X,Y,Z){
      const a=6378137, e2=6.69437999014e-3, b=Math.sqrt(a*a*(1-e2));
      const ep2 = (a*a - b*b)/(b*b);
      const p = Math.sqrt(X*X + Y*Y);
      const th = Math.atan2(a*Z, b*p);
      const lon = Math.atan2(Y,X);
      const lat = Math.atan2(Z + ep2*b*Math.sin(th)**3, p - e2*a*Math.cos(th)**3);
      const N = a/Math.sqrt(1 - e2*Math.sin(lat)**2);
      // altitude not needed; we skip iteration for simplicity
      return { lat: rad2deg(lat), lon: rad2deg(lon) };
    }

    // --- Very simple MGRS/USNG stub: accepts grid like "4QFJ 12345 67890" and treats it as UTM zone 4Q approx. ---
    // This is intentionally minimal: it only recognizes the pattern and falls back if not parseable.
    function parseMGRS(text){
      const s = text.trim().toUpperCase();
      // Basic tokenization: <zone><band><grid> <easting> <northing>
      const m = s.match(/^(\d{1,2})([C-HJ-NP-X])\s*([A-HJ-NP-Z]{2})\s+(\d{2,5})\s+(\d{2,5})$/);
      if(!m) return null;
      // A full MGRS decode is lengthy; here we fail gracefully:
      // Tell the user to paste UTM instead if this didn't work for their grid square.
      // Return null to let other parsers try.
      return null;
    }

    function toFeature(geom){
      if(geom.type==='Feature' || geom.type==='FeatureCollection') return geom;
      return { type:'Feature', properties:{}, geometry: geom };
    }
    function toFeatureCollection(obj){
      if(obj.type==='FeatureCollection') return obj;
      if(obj.type==='Feature') return { type:'FeatureCollection', features:[obj] };
      return { type:'FeatureCollection', features:[{ type:'Feature', properties:{}, geometry: obj }] };
    }

    function guessGeometry(text){
      // 1) GeoJSON or WKT
      let g = parseGeoJSON(text); if(g) return g;
      g = parseWKT(text); if(g) return toFeature(g);
      // 2) ECEF
      g = parseECEF(text); if(g) return toFeature(g);
      // 3) UTM
      g = parseUTM(text); if(g) return toFeature(g);
      // 4) DMS single pair
      const dms = parseDMS(text); if(dms) return toFeature({ type:'Point', coordinates:[dms.lon,dms.lat] });
      // 5) Decimal lists / bbox / line
      g = parseLatLonList(text); if(g) return toFeature(g);
      // 6) (Optional) MGRS stub (currently returns null to avoid bad guesses)
      g = parseMGRS(text); if(g) return toFeature(g);

      return null;
    }
	
	// ---- China coordinate systems → WGS84 (minimal, commonly used formulas)
	const PI_CN = Math.PI;
	const A_CN = 6378245.0; // Krasovsky ellipsoid
	const EE_CN = 0.00669342162296594323;
	const X_PI = PI_CN * 3000.0 / 180.0;

	function outOfChina(lng, lat){
	  return (lng < 72.004 || lng > 137.8347 || lat < 0.8293 || lat > 55.8271);
	}
	function transformLat(lng, lat){
	  let ret = -100.0 + 2.0*lng + 3.0*lat + 0.2*lat*lat + 0.1*lng*lat + 0.2*Math.sqrt(Math.abs(lng));
	  ret += (20.0*Math.sin(6.0*lng*PI_CN) + 20.0*Math.sin(2.0*lng*PI_CN)) * 2.0/3.0;
	  ret += (20.0*Math.sin(lat*PI_CN) + 40.0*Math.sin(lat/3.0*PI_CN)) * 2.0/3.0;
	  ret += (160.0*Math.sin(lat/12.0*PI_CN) + 320.0*Math.sin(lat*PI_CN/30.0)) * 2.0/3.0;
	  return ret;
	}
	function transformLon(lng, lat){
	  let ret = 300.0 + lng + 2.0*lat + 0.1*lng*lng + 0.1*lng*lat + 0.1*Math.sqrt(Math.abs(lng));
	  ret += (20.0*Math.sin(6.0*lng*PI_CN) + 20.0*Math.sin(2.0*lng*PI_CN)) * 2.0/3.0;
	  ret += (20.0*Math.sin(lng*PI_CN) + 40.0*Math.sin(lng/3.0*PI_CN)) * 2.0/3.0;
	  ret += (150.0*Math.sin(lng/12.0*PI_CN) + 300.0*Math.sin(lng/30.0*PI_CN)) * 2.0/3.0;
	  return ret;
	}
	function deltaGCJ(lng, lat){
	  const dLat = transformLat(lng-105.0, lat-35.0);
	  const dLng = transformLon(lng-105.0, lat-35.0);
	  const radLat = lat / 180.0 * PI_CN;
	  let magic = Math.sin(radLat);
	  magic = 1 - EE_CN*magic*magic;
	  const sqrtMagic = Math.sqrt(magic);
	  const dLat2 = (dLat*180.0) / ((A_CN*(1-EE_CN)) / (magic*sqrtMagic) * PI_CN);
	  const dLng2 = (dLng*180.0) / (A_CN / sqrtMagic * Math.cos(radLat) * PI_CN);
	  return { dlat: dLat2, dlng: dLng2 };
	}
	// GCJ-02 → WGS84 (approx inverse)
	function gcj02_to_wgs84(lng, lat){
	  if (outOfChina(lng, lat)) return [lng, lat];
	  const d = deltaGCJ(lng, lat);
	  return [lng - d.dlng, lat - d.dlat];
	}
	
	// Forward: WGS84 -> GCJ-02 (needed for the inverse iteration)
	function wgs84_to_gcj02(lng, lat){
	  if (outOfChina(lng, lat)) return [lng, lat];
	  const d = deltaGCJ(lng, lat);
	  return [lng + d.dlng, lat + d.dlat];
	}

	// Inverse (iterative): GCJ-02 -> WGS84 (high accuracy)
	function gcj02_to_wgs84_exact(lng, lat){
	  if (outOfChina(lng, lat)) return [lng, lat];
	  // start from the approximate inverse
	  let wgsLng = lng, wgsLat = lat;
	  for (let i = 0; i < 10; i++) {
	    const [gLng, gLat] = wgs84_to_gcj02(wgsLng, wgsLat);
	    const dLng = gLng - lng;
	    const dLat = gLat - lat;
	    wgsLng -= dLng;
	    wgsLat -= dLat;
	    if (Math.max(Math.abs(dLng), Math.abs(dLat)) < 1e-7) break; // ~1 cm
	  }
	  return [wgsLng, wgsLat];
	}
	// BD-09 → GCJ-02
	function bd09_to_gcj02(lng, lat){
	  const x = lng - 0.0065, y = lat - 0.006;
	  const z = Math.sqrt(x*x + y*y) - 0.00002 * Math.sin(y * X_PI);
	  const theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * X_PI);
	  const gg_lng = z * Math.cos(theta);
	  const gg_lat = z * Math.sin(theta);
	  return [gg_lng, gg_lat];
	}
	// BD-09 -> WGS84 using exact inverse via GCJ-02
	function bd09_to_wgs84(lng, lat){
	  const [gLng, gLat] = bd09_to_gcj02(lng, lat);
	  return gcj02_to_wgs84_exact(gLng, gLat);
	}

	// Traverse & convert GeoJSON geometries in-place
	function mapCoords(geom, fn){
	  const t = geom.type;
	  if (t === 'Point') geom.coordinates = fn(geom.coordinates);
	  else if (t === 'LineString' || t === 'MultiPoint') geom.coordinates = geom.coordinates.map(fn);
	  else if (t === 'Polygon' || t === 'MultiLineString') geom.coordinates = geom.coordinates.map(r => r.map(fn));
	  else if (t === 'MultiPolygon') geom.coordinates = geom.coordinates.map(p => p.map(r => r.map(fn)));
	  else if (t === 'GeometryCollection' && Array.isArray(geom.geometries)) geom.geometries.forEach(g => mapCoords(g, fn));
	  return geom;
	}

	function convertChinaGeom(geom, mode){
	  const conv = (xy)=>{
	    const [lng, lat] = xy;

	    if (mode === 'bd09') return bd09_to_wgs84(lng, lat);
	    // default gcj02 (use exact inverse)
	    return gcj02_to_wgs84_exact(lng, lat);
	  };
	  return mapCoords(geom, conv);
	}
	function convertChinaFeature(feature, mode){
	  if (feature && feature.geometry) feature.geometry = convertChinaGeom(feature.geometry, mode);
	  return feature;
	}
	function convertChinaFC(fc, mode){
	  if (fc.type === 'FeatureCollection') { fc.features = fc.features.map(f => convertChinaFeature(f, mode)); return fc; }
	  if (fc.type === 'Feature') return convertChinaFeature(fc, mode);
	  // raw geometry -> wrap
	  return { type:'Feature', properties:{}, geometry: convertChinaGeom(fc, mode) };
	}

    async function handle(text, replace){
		lastInputSource = 'pasted';
		lastParseMeta = null;
      msg.textContent = '';
      const geomOrFC = guessGeometry(text || '');
      if(!geomOrFC){ msg.textContent = 'Could not detect format. Try WKT, GeoJSON, lat,lon, UTM, DMS, or ECEF.'; return; }

      const fc = toFeatureCollection(geomOrFC);
	  
	  // If user marked China coordinate systems, convert to WGS84
	  const chinaBox = document.getElementById('chinaCoords');
	  if (chinaBox && chinaBox.checked) {
	    const modeSel = document.getElementById('chinaType');
	    const mode = (modeSel && modeSel.value) || 'gcj02';
	    convertChinaFC(fc, mode);
	  }
	  const hintText = buildHintFromMeta(lastInputSource, lastParseMeta, fc);
	  hint.textContent = hintText;
	  updateHintWithLocation(fc); // ← añade país/región de forma asíncrona
	  result.style.display = 'block'; 
      ensureMap();
      lastGeoJSON = fc;
      drawGeoJSON(fc);
      summarizeGeoJSON(fc);
	  switchTab('map');
	  showGfwPanel();
	  //toggleLossTiles();
	  //togglePlantationsTiles();
	  scrollToResult();
	  runGfwValidation();
      msg.textContent = 'Parsed successfully.';
	   // --- update Raw JSON panel ---
	  el('json').textContent = JSON.stringify(fc, null, 2);

	  // === make downloadable ===
	  const blob = new Blob([JSON.stringify(fc, null, 2)], { type: 'application/geo+json' });
	  const url = URL.createObjectURL(blob);
	  download.href = url;
	  download.setAttribute('download', 'pasted.geojson');
	  // opcional: tamaño en meta
	  //meta.textContent = `pasted.geojson • ${(blob.size/1024).toFixed(1)} KB`;
	  
	  
    }

    btnPrev.addEventListener('click', ()=> handle(tArea.value, false));
    btnUse .addEventListener('click', ()=> handle(tArea.value, true));
  })();

  /* =========================
     GFW integration
     ========================= */
  const GFW_API_KEY = '10f7953e-c8db-4d34-99c3-ea4bb4a74766';
  
  const GFW_BASE = 'https://data-api.globalforestwatch.org';
  const GFW_BASE_PROXY = 'https://corsproxy.io/?url=https://data-api.globalforestwatch.org';
  const TILE_BASE = 'https://tiles.globalforestwatch.org';
  const DATASET = 'umd_tree_cover_loss';
  const VERSION = 'v1.12'; // Ajusta si cambia la versión publicada
  const YEARS = { start: 2020, end: 2024 };
  const EUDR_RESULTS = {
    COMPLIANT:        { label: 'Compliant',         color: '#e6f4ea' }, // verde muy claro
    NEED_VERIFICATION:{ label: 'Need verification', color: '#fffbe6' }, // amarillo pálido
    NOT_COMPLIANT:    { label: 'Not compliant',     color: '#fde8e8' }  // rojo muy claro
  };
  const PLANTATIONS_TILE= 'https://tiles.globalforestwatch.org/gfw_planted_forests/v20231128/corrected/{z}/{x}/{y}.png'; 
  const TILE_LOSS = `${TILE_BASE}/umd_tree_cover_loss/v1.12/tcd_30/{z}/{x}/{y}.png`;
  const TILE_PLANT = `${TILE_BASE}/gfw_planted_forests/v20231128/corrected/{z}/{x}/{y}.png`;
  const TILE_WOOD  = `${TILE_BASE}/gfw_wood_fiber/v202106/{z}/{x}/{y}.png`;
  const TILE_MANAGED = `${TILE_BASE}/gfw_managed_forests/v202106/{z}/{x}/{y}.png`;
  let gfwPlantLayer = null;
  let lastValidation = null; // { code: 'COMPLIANT'|'NEED_VERIFICATION'|'NOT_COMPLIANT', verdict, reason, notes }
  const gfwMsg       = document.getElementById('gfwMsg');

  let gfwTileLayer = null;
  
  async function postQuery(dataset, version, sql, geometry){
    const url = `${GFW_BASE}/dataset/${dataset}/${version}/query/json`;
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type':'application/json', 'x-api-key': GFW_API_KEY },
      body: JSON.stringify({ sql, geometry: geometry })
    });
    const j = await res.json();
    if (!res.ok) throw new Error(j?.errors?.[0]?.detail || JSON.stringify(j));
    return j;
  }
  function normalizeGeometryForQuery(geometry){
    if (geometry?.type === 'Point' && Array.isArray(geometry.coordinates)) {
      return pointToSquarePolygon(geometry.coordinates, 30);
    }
    return geometry;
  }
  
  function pointToSquarePolygon(coords, sizeMeters = 30){
    const [lng, lat] = coords;
    const half = sizeMeters / 2;

    // 1° lat ≈ 111320 m; 1° lon ≈ 111320 * cos(lat)
    const dLat = half / 111320;
    const cosLat = Math.cos(lat * Math.PI / 180);
    const metersPerDegLon = 111320 * Math.max(0.01, Math.abs(cosLat)); // evita divisiones por ~0 en latitudes extremas
    const dLon = half / metersPerDegLon;

    const ring = [
      [lng - dLon, lat - dLat],
      [lng + dLon, lat - dLat],
      [lng + dLon, lat + dLat],
      [lng - dLon, lat + dLat],
      [lng - dLon, lat - dLat] // cierre
    ];
    return { type:'Polygon', coordinates:[ring] };
  }

  async function createGeostoreFromGeometry(geometry) {
	  
	  // Si es un Point, conviértelo en un cuadrado ~30x30 m en WGS84
	  if (geometry?.type === 'Point' && Array.isArray(geometry.coordinates)) {
	      geometry = pointToSquarePolygon(geometry.coordinates, 30);
	  }
    const res = await fetch(`${GFW_BASE}/geostore/`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        //'x-api-key': gfwKeyInput.value.trim()
		  'x-api-key': GFW_API_KEY
      },
      body: JSON.stringify({ geometry })
    });
    const j = await res.json();
    if (!res.ok) throw new Error(j?.errors?.[0]?.detail || JSON.stringify(j));
    const id = j?.data?.id || j?.data?.gfw_geostore_id;
    if (!id) throw new Error('No geostore_id in response');
    return id;
  }

  async function queryLossYesNo(geometry) {
    const sql = `
      SELECT SUM(area__ha) AS area_ha
      FROM data
      WHERE umd_tree_cover_loss__year >= ${YEARS.start} 
    `.trim();
	const j = await postQuery(DATASET, VERSION, sql, geometry);
	const val = Number(j?.data?.[0]?.area_ha || 0);
	return { areaHa: val, hasLoss: isFinite(val) && val > 0 };
  }
  
  async function queryPlantedForest(geometry) {
    const dataset = 'gfw_planted_forests';
    const version = 'v20231128';
    const sql = encodeURIComponent('SELECT COUNT(*) AS pixels_in_plantation FROM gfw_planted_forests');
    const key = GFW_API_KEY;
	const j = await postQuery(dataset, version, sql, geometry);
    const val = Number(j?.data?.[0]?.pixels_in_plantation || 0);
    return val > 0;
  }
  async function queryWoodFiber(geometry) {
    const dataset = 'gfw_wood_fiber';
    const version = 'v202106';
    const sql = encodeURIComponent('SELECT COUNT(*) AS pixels_in_wood_fiber FROM gfw_wood_fiber');
    const key = GFW_API_KEY;
	const j = await postQuery(dataset, version, sql, geometry);
    const val = Number(j?.data?.[0]?.pixels_in_wood_fiber || 0);
    return val > 0;
  }

  async function queryManagedForests(geometry) {
    const dataset = 'gfw_managed_forests';
    const version = 'v202106';
    const sql = encodeURIComponent('SELECT COUNT(*) AS pixels_in_managed FROM gfw_managed_forests');
    const key = GFW_API_KEY;
	const j = await postQuery(dataset, version, sql, geometry);
    const val = Number(j?.data?.[0]?.pixels_in_managed || 0);
    return val > 0;
  }
  async function queryWDPA(geometry) {
    const dataset = 'wdpa_protected_areas';
    const version = 'v202407';
    const sql = encodeURIComponent('SELECT COUNT(*) AS features_in_wdpa FROM wdpa_protected_areas');
    const key = GFW_API_KEY;
	const j = await postQuery(dataset, version, sql, geometry);
    const val = Number(j?.data?.[0]?.features_in_wdpa || 0);
    return val > 0;
  }

  async function querySBTNNaturalForests(geometry) {
    const dataset = 'sbtn_natural_forests_map';
    const version = 'v202410';
    // Nota: sin filtrar por clase para mantener coherencia con tu patrón "FROM <dataset>"
    const sql = encodeURIComponent('SELECT COUNT(*) AS features_in_sbtn FROM sbtn_natural_forests_map');
    const key = GFW_API_KEY;
	const j = await postQuery(dataset, version, sql, geometry);
    const val = Number(j?.data?.[0]?.features_in_sbtn ?? j?.data?.[0]?.count ?? 0);
    return val > 0;
  }

  
  function assessEUDR({ hasLoss, inPlantation, inManagedForest, inWoodFiber, inWDPA, inSBTN }, years){
    const ctx = [];
    const inProductive = !!(inPlantation || inManagedForest || inWoodFiber);

    // Priority 1: Protected areas
    if (inWDPA) {
      return { code: 'NOT_COMPLIANT', verdict: 'Not compliant', level: 'high', 
        reason: 'Inside protected area (WDPA). Extraction likely illegal.',
        notes: ['Prohibit sourcing.'] };
    }

    // Priority 0: Loss baseline
    if (hasLoss && !inProductive) {
      return { code: 'NOT_COMPLIANT', verdict: 'Not compliant', level: 'high',
        reason: `Tree cover loss in ${years.start}–${years.end} outside plantation/managed areas (deforestation).`,
        notes: ['Reject or investigate exceptional legal authorization.'] };
    }

    // Priority 2: Natural forest
    if (inSBTN && !inProductive) {
      if (hasLoss) {
        return { code: 'NOT_COMPLIANT', verdict: 'Not compliant', level: 'high',
          reason: `Loss detected in natural forest (SBTN).`,
          notes: ['Reject under EUDR deforestation definition.'] };
      }
      // pre-extraction case or no observed loss
      return { code: 'NEED_VERIFICATION', verdict: 'Needs verification', level: 'medium-high',
        reason: 'Natural forest (SBTN). Any extraction risks conversion.',
        notes: ['Require robust evidence of non-conversion and legal authorization.'] };
    }

    // Priority 3: Productive forest (plantation / managed / wood fiber)
    if (inProductive) {
      if (hasLoss) {
        return { code: 'COMPLIANT', verdict: 'Compliant', level: 'low',
          reason: `Loss only within plantation/managed forest (rotation/harvest).`,
          notes: ['Keep permit/concession evidence.'] };
      }
      return { code: 'COMPLIANT', verdict: 'Compliant', level: 'low',
        reason: 'Inside plantation/managed forest with no loss since 2020.',
        notes: ['Collect/verify permits and management docs.'] };
    }

    // Priority 4: Everything else
    if (hasLoss) {
      return { code: 'NOT_COMPLIANT', verdict: 'Not compliant', level: 'high',
        reason: `Loss detected in ${years.start}–${years.end} outside recognized forest management/plantation.`,
        notes: ['Reject unless strong contrary evidence.'] };
    } else {
      return { code: 'NEED_VERIFICATION', verdict: 'Needs verification', level: 'medium-high',
        reason: 'No loss detected, but area is outside mapped forest/plantation layers.',
        notes: ['Demonstrate non-forest status since 2020 (imagery, land registers).'] };
    }
  }
  
  async function runGfwValidation(){
    const gfwMsg = document.getElementById('gfwMsg');
    gfwMsg.textContent = 'Validating…';
	const panel = document.getElementById('gfwPanel');
	if (panel) panel.style.backgroundColor = '';

    // Toma la primera geometría del lastGeoJSON
    let geom = null;
    if (lastGeoJSON.type === 'FeatureCollection') {
      const f = (lastGeoJSON.features || []).find(ff => ff && ff.geometry);
      geom = f?.geometry || null;
    } else if (lastGeoJSON.type === 'Feature') {
      geom = lastGeoJSON.geometry;
    } else {
      geom = lastGeoJSON;
    }
    if (!geom) { gfwMsg.textContent = 'No geometry found in GeoJSON.'; return; }

    try{
	  const geomQ = normalizeGeometryForQuery(geom);
	  const { areaHa, hasLoss } = await queryLossYesNo(geomQ);
	  const inPlantation     = await queryPlantedForest(geomQ);
	  const inWoodFiber      = await queryWoodFiber(geomQ);
	  const inManagedForest  = await queryManagedForests(geomQ);
	  const inWDPA           = await queryWDPA(geomQ);
	  const inSBTN           = null;

      const res = assessEUDR(
        { hasLoss, inPlantation, inManagedForest, inWoodFiber, inWDPA, inSBTN },
        YEARS
      );
      gfwMsg.textContent = `${res.verdict} — ${res.reason}`;
	  const panel = document.getElementById('gfwPanel');
	  lastValidation = res; // guarda el resultado estructurado
	  if (panel && res?.code && EUDR_RESULTS[res.code]) {
	    panel.style.backgroundColor = EUDR_RESULTS[res.code].color;
	  }
    } catch(e){
      console.error(e);
      gfwMsg.textContent = `Error: ${e.message || e}`;
    }
  }

})();
</script>
</body>
</html>
